<!DOCTYPE html>
<html>


<head>
    <title>Prototype Emotional Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .auth-section { margin-bottom: 30px; padding: 20px; background: #e8f4fd; border-radius: 8px; }
        .chart-container { margin: 20px 0; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; padding: 10px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>


<body>
  <div class="container">
    <h1>ü´Ä Emotional Map</h1>

    <!-- Section d'authentification -->
    <div id="authSection" style="display:{{authSectionDisplay}};">
      
      <div class="info">
        <strong>Configuration:</strong> {{numSeats}} Valid ids from 1 to {{numSeats}}
      </div>

      <h3>Authentification</h3>
      <input type="text" id="userIdInput" placeholder="Id (1 to {{numSeats}})" />
      <button class="btn-primary" onclick="authenticateUser()">Connect</button>
      <div id="authStatus"></div>
    </div>

    <!-- Section principale -->
    <div id="mainSection" style="display:{{mainSectionDisplay}};">
      <div class="chart-container">
        <h3 id="chartTitle">S√©lectionnez un profil</h3>
        <canvas id="bpmChart" width="400" height="200"></canvas>
      </div>

      <button class="btn-success" onclick="logout()">D√©connexion</button>
    </div>
  </div>

<script>
  let chart = null;
  let currentUser = '{{autoAuth}}' === 'true' ? '{{userId}}' : null;
  let connectionCount = '{{autoAuth}}' === 'true' ? 1 : 0;

  const validUsers = [{{validUsersString}}];
  const autoAuth = '{{autoAuth}}' === 'true';
  const presetUserId = '{{userId}}';

  // Authentification automatique au chargement si n√©cessaire
  window.onload = function() {
    if (autoAuth && presetUserId) {
      authenticateUserAuto(presetUserId);
    }
  };

  function authenticateUserAuto(userId) {
    fetch(`/api/auth/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          currentUser = userId;
          connectionCount++;
          showMainSection();
          loadBpmData(userId);
        } else {
          console.error('√âchec authentification automatique');
        }
      })
      .catch(error => {
        console.error('Erreur authentification automatique:', error);
      });
  }

  function authenticateUser() {

    let userId = document.getElementById('userIdInput').value.trim();
    const statusDiv = document.getElementById('authStatus');

    if (!validUsers.includes(userId)) {
      console.log("chelou");
      statusDiv.innerHTML = '<div class="status error">‚ùå Invalid id. Valid ids within 1 and {{numSeats}}.</div>';
      return;
    }

    fetch(`/api/auth/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          statusDiv.innerHTML = `<div class="status success">‚úÖ Authentifi√©: ${data.profile}</div>`;
          currentUser = userId;
          connectionCount++;
          showMainSection();
          loadBpmData(userId);
        } else {
          statusDiv.innerHTML = '<div class="status error">‚ùå √âchec authentification</div>';
        }
      })
      .catch(error => {
        console.error('Erreur:', error);
        statusDiv.innerHTML = '<div class="status error">‚ùå Erreur r√©seau</div>';
      });
  }

  function showMainSection() {
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('mainSection').style.display = 'block';
  }
    function logout() {
      // Reset values
      currentUser = null;
      if(chart) {
        chart.destroy();
        chart = null;
      }
      document.getElementById('authStatus').innerHTML = '';
      document.getElementById('userIdInput').value = '';

      // Redirect toward authentication page
      window.location.href = '/';
    }

  function loadBpmData(userId) {
    fetch(`/api/bpm/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          document.getElementById('chartTitle').textContent = `üìä ${data.profile} - BPM au cours du spectacle`;
          updateChart(data.bpmData, data.time, data.profile, data.avg, data.avgTime);
        }
      })
      .catch(error => console.error('Erreur BPM:', error));
  }

  function updateChart(bpmData, time, profileName, avgBpm, avgTime) {
      // Prendre le premier timestamp comme origine
      const startTime = time[0];

      // Convertir les timestamps en temps relatif depuis le d√©but (en heures:minutes)
      const labels = time.map(timestamp => {
        const elapsedSeconds = (timestamp - startTime)/1000;
        const hours = Math.floor(elapsedSeconds / 3600);
        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
      
        return hours + ':' + minutes.toString().padStart(2, '0');
      });
      
      // Define y bounds
      const allBpmValues = [...bpmData, ...avgBpm].filter(val => val !== null);
      const minBpm = Math.min(...allBpmValues);
      const maxBpm = Math.max(...allBpmValues);

      const yMinBound = Math.floor( (minBpm - (maxBpm-minBpm)*0.2) / 10 ) * 10;  
      const yMaxBound = Math.ceil( (maxBpm + (maxBpm-minBpm)*0.2) / 10 ) * 10; 

      // Define datasets
      const datasets = [
        {
          label: profileName,
          data: bpmData,
          borderColor: '#36A2EB',
          borderWidth: 2,
          radius: 0,
          tension: 0.2,
          pointHoverRadius: 5
        },
        {
          label: 'Moyenne public',
          data: avgBpm,
          borderColor: '#dd7768',
          borderWidth: 2,
          radius: 0,
          tension: 0.2,
          pointHoverRadius: 5
        }
      ];
      
      // Make sure no chart is already here
      if (chart) {
          chart.destroy();
      }

      // Define animation
      const totalDuration = 5000;
      const delayBetweenPoints = totalDuration / bpmData.length;
      const previousY = (ctx) => ctx.index === 0 ? ctx.chart.scales.y.getPixelForValue(100) : ctx.chart.getDatasetMeta(ctx.datasetIndex). data[ctx.index - 1].getProps(['y'], true).y;
      const animation = {
        x: {
          type: 'number',
          easing: 'linear',
          duration: delayBetweenPoints,
          from: NaN, // the point is initially skipped
          delay(ctx) {
            if (ctx.type !== 'data' || ctx.xStarted) {
              return 0;
            }
            ctx.xStarted = true;
            return ctx.index * delayBetweenPoints;
          }
        },
        y: {
          type: 'number',
          easing: 'linear',
          duration: delayBetweenPoints,
          from: previousY,
          delay(ctx) {
            if (ctx.type !== 'data' || ctx.yStarted) {
              return 0;
            }
            ctx.yStarted = true;
            return ctx.index * delayBetweenPoints;
          }
        }
      };

      // Create chart
      chart = new Chart(document.getElementById('bpmChart').getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          animation,
          responsive: true,
          scales: {
            y: {
              beginAtZero: false,
              min: yMinBound,
              max: yMaxBound,
              title: {
                display: true,
                text: 'BPM'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Elapsed time (h:min)'
              },
              ticks: {
                maxTicksLimit: 10, // Label nb limit
                maxRotation: 45,   // Rotation des labels si n√©cessaire
                minRotation: 0
              }
            }
          }
        }
      });
    }
  
</script>
</body>
</html>