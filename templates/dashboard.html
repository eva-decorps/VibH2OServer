<!DOCTYPE html>
<html>


<head>
    <title>Prototype Emotional Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .auth-section { margin-bottom: 30px; padding: 20px; background: #e8f4fd; border-radius: 8px; }
        .chart-container { margin: 20px 0; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; padding: 10px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>


<body>
  <div class="container">
    <h1>ü´Ä Emotional Map</h1>

    <!-- Section d'authentification -->
    <div id="authSection" style="display:{{authSectionDisplay}};">
      
      <div class="info">
        <strong>Configuration:</strong> {{numSeats}} Valid ids from 1 to {{numSeats}}
      </div>

      <h3>Authentification</h3>
      <input type="text" id="userIdInput" placeholder="Id (1 to {{numSeats}})" />
      <button class="btn-primary" onclick="authenticateUser()">Connect</button>
      <div id="authStatus"></div>
    </div>

    <!-- Section principale -->
    <div id="mainSection" style="display:{{mainSectionDisplay}};">
      <div class="chart-container">
        <h3 id="chartTitle">S√©lectionnez un profil</h3>
        <canvas id="bpmChart" width="400" height="200"></canvas>
      </div>

      <button class="btn-success" onclick="logout()">D√©connexion</button>
    </div>
  </div>

<script>
  let chart = null;
  let currentUser = '{{autoAuth}}' === 'true' ? '{{userId}}' : null;
  let connectionCount = '{{autoAuth}}' === 'true' ? 1 : 0;

  const validUsers = [{{validUsersString}}];
  const autoAuth = '{{autoAuth}}' === 'true';
  const presetUserId = '{{userId}}';

  // Authentification automatique au chargement si n√©cessaire
  window.onload = function() {
    if (autoAuth && presetUserId) {
      authenticateUserAuto(presetUserId);
    }
  };

  function authenticateUserAuto(userId) {
    fetch(`/api/auth/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          currentUser = userId;
          connectionCount++;
          showMainSection();
          loadBpmData(userId);
        } else {
          console.error('√âchec authentification automatique');
        }
      })
      .catch(error => {
        console.error('Erreur authentification automatique:', error);
      });
  }

  function authenticateUser() {

    let userId = document.getElementById('userIdInput').value.trim();
    const statusDiv = document.getElementById('authStatus');

    if (!validUsers.includes(userId)) {
      console.log("chelou");
      statusDiv.innerHTML = '<div class="status error">‚ùå Invalid id. Valid ids within 1 and {{numSeats}}.</div>';
      return;
    }

    fetch(`/api/auth/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          statusDiv.innerHTML = `<div class="status success">‚úÖ Authentifi√©: ${data.profile}</div>`;
          currentUser = userId;
          connectionCount++;
          showMainSection();
          loadBpmData(userId);
        } else {
          statusDiv.innerHTML = '<div class="status error">‚ùå √âchec authentification</div>';
        }
      })
      .catch(error => {
        console.error('Erreur:', error);
        statusDiv.innerHTML = '<div class="status error">‚ùå Erreur r√©seau</div>';
      });
  }

  function showMainSection() {
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('mainSection').style.display = 'block';
  }

  function logout() {
    currentUser = null;
    connectionCount = 0;
    if(chart) {
      chart.destroy();
      chart = null;
    }
    document.getElementById('authStatus').innerHTML = '';
    document.getElementById('userIdInput').value = '';
    document.getElementById('chartTitle').textContent = 'S√©lectionnez un profil';
    
    if (autoAuth) {
      // Si on √©tait en mode auto-auth, rediriger vers la page d'accueil
      window.location.href = '/';
    } else {
      // Sinon, juste masquer la section principale
      document.getElementById('mainSection').style.display = 'none';
      document.getElementById('authSection').style.display = 'block';
    }
  }

  function loadBpmData(userId) {
    fetch(`/api/bpm/${userId}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          document.getElementById('chartTitle').textContent = `üìä ${data.profile} - BPM au cours du spectacle`;
          updateChart(data.bpmData, data.time, data.profile, data.avg, data.avgTime);
        }
      })
      .catch(error => console.error('Erreur BPM:', error));
  }

  function updateChart(bpmData, time, profileName, avgBpm, avgTime) {
    // Prendre le premier timestamp comme origine
    const startTime = time[0];

    // Convertir les timestamps en temps relatif depuis le d√©but (en heures:minutes)
    const labels = time.map(timestamp => {
      const elapsedSeconds = (timestamp - startTime)/1000;
      const hours = Math.floor(elapsedSeconds / 3600);
      const minutes = Math.floor((elapsedSeconds % 3600) / 60);
    
      return hours + ':' + minutes.toString().padStart(2, '0');
    });

    const bpmPoints = time.map((t, i) => ({
      x: (t - time[0]) / 60000, // temps relatif en minutes
      y: bpmData[i]
    }));

    const avgPoints = avgTime.map((t, i) => ({
      x: (t - time[0]) / 60000, // temps relatif en minutes
      y: avgBpm[i]
    }));

    const minBpm = Math.min(Math.min(...bpmData), Math.min(...avgBpm));
    const maxBpm = Math.max(Math.max(...bpmData), Math.max(...avgBpm));

    const xMinBound = Math.floor( (minBpm - (maxBpm-minBpm)*0.2) / 10 ) * 10;  
    const xMaxBound = Math.ceil( (maxBpm + (maxBpm-minBpm)*0.2) / 10 ) * 10; 

    // Pr√©parer les datasets avec leurs propres labels
    const datasets = [
      {
        label: profileName,
        data: bpmPoints,
        borderColor: '#36A2EB',
        borderWidth: 2,
        radius: 0,
        tension: 0.4,
        pointHoverRadius: 5,
        parsing: false // Indique √† Chart.js qu'on fournit {x,y}
      },
      {
        label: 'Moyenne public',
        data: avgPoints,
        borderColor: '#FF6384',
        borderWidth: 2,
        radius: 0,
        tension: 0.4,
        pointHoverRadius: 5,
        parsing: false
      }
    ];

    if (chart) {
        chart.destroy();
    }

    const totalDuration = 10000;
    const delayBetweenPoints = totalDuration / bpmData.length;
    const previousY = (ctx) => ctx.index === 0 ? ctx.chart.scales.y.getPixelForValue(100) : ctx.chart.getDatasetMeta(ctx.datasetIndex).data[ctx.index - 1].getProps(['y'], true).y;
    const animation = {
      x: {
        type: 'number',
        easing: 'linear',
        duration: delayBetweenPoints,
        from: NaN, // the point is initially skipped
        delay(ctx) {
          if (ctx.type !== 'data' || ctx.xStarted) {
            return 0;
          }
          ctx.xStarted = true;
          return ctx.index * delayBetweenPoints;
        }
      },
      y: {
        type: 'number',
        easing: 'linear',
        duration: delayBetweenPoints,
        from: previousY,
        delay(ctx) {
          if (ctx.type !== 'data' || ctx.yStarted) {
            return 0;
          }
          ctx.yStarted = true;
          return ctx.index * delayBetweenPoints;
        }
      }
    };

    chart = new Chart(document.getElementById('bpmChart').getContext('2d'), {
      type: 'line',
      data: {
        labels: labels,
        datasets: datasets
      },
      options: {
        animation,
        responsive: true,
        scales: {
          y: {
            beginAtZero: false,
            min: xMinBound,
            max: xMaxBound,
            title: {
              display: true,
              text: 'BPM'
            }
          },
          x: {
            type: 'linear',
            min: 0,
            max: Math.max(...bpmPoints.map(p => p.x), ...avgPoints.map(p => p.x)),
            title: {
              display: true,
              text: 'Temps √©coul√© (min)'
            }
          }
        }
      }
    });
  }
  
</script>
</body>
</html>